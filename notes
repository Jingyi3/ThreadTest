---------------------------高并发1---------------------------
【synchronized】
1. synchronized锁定的是【对象】
2. synchronized加在一个方法申明上面的时候锁定的是【this】当前对象
3. synchronized加在一个static方法的时候锁定的是【类.class】对象
4. 如果使用synchronized的方法加锁，当出现异常，java虚拟机会自动帮你释放锁
5. 将synchronized的代码块尽量缩小，可以使锁效率更高
6. synchronized 是不公平锁：不一定等的最久的就会进去

【同步的方法和非同步的方法是否可以同时调用？】
--可以，同步的方法需要锁，非同步的方法并不需要锁，不需要锁就不冲突

【一个同步方法可以调用另外一个同步方法，子类的同步方法也可以调父类的同步方法】

【脏读问题dirtyRead】
对业务写方法加锁，对业务读方法不加锁-->造成在读的时候，会读到你还没有写完的数据
解决：CopyOnWrite 牺牲写性能增加读性能

【volatile关键字】
每一个线程在读取主内存的数据的时候会在自己的线程缓存中留一份，合适的时候会写回去。
当没有写回去的时候，你访问的内容，很可能两个线程改了的内容互相不可见。
1. 加上volatile的话，当你写到主内存之后，他会通知其他线程的缓存你的数据已经过期了，马上刷新，这样保证了线程的可见性。
2. volatile不能替代synchronized 因为v只解决了可见性，没有解决原子性。

【AtomicXXX】
比较简单的自增自减，想要使其变为原子性操作可以使用AtomicXXX

【锁是否有变更】
1. 如果锁的对象的属性发生了变化，不影响锁的使用
2. 如果锁把这个引用指向了新的对象，那么这个锁就变了
3. 所以锁是锁在堆空间里，锁的是对象；而不是在栈空间里的引用
4. 在锁里面不要使用【字符串常量】作为锁定的对象，不小心就会产生死锁的问题

【两个线程之间互相通信】
1. wait/notify
   1）wait释放锁；notify不释放锁，如果想要释放锁需要在notify之后再wait释放当前的锁
   2）必须要在synchronized当中使用，首先锁定。
2. 同步器【CountDownLatch/cyclicbarrier/semaphore】
   1） 【CountDownLatch】 门闩 当初始值==0的时候，门闩就开了

---------------------------高并发2---------------------------
【高并发的四大问题】
1. 同步器 synchronizer --线程之间的同步和tongxin
2. 同步性容器 concurrentMap/concurrentList/copyOnWrite/bolckInQueue
3. 线程池 ThreadPool/executor/future/collllllable
4.


【Thread实现方法】
1. 继承Thread类
2. 实现Runnable接口
3. 实现Callable接口

【Reentrantlock】
1. 可以替代synchronized
2. 比syn灵活
   1）可以用tryLock尝试锁定，根据锁定的结果，还可以指定的额时间，来处理
   2）lockInterruptibly 可以通过lock.interrupt来打断我
3. 是公平锁：谁等的时间长，谁就会得到这把锁
4. 区别：

【生产者消费者模型】
1. get和out方法都需要使用【while】来判断【满/空】
2. 注意【wait】99.9%的情况下，都需要用while！！！
3. synchronized-wait-notify[汇编式的写法需要精确控制才可以]
4. lock-await-signal[在不同的condition情况下，精确的让某些线程睡着，让某些线程醒来];

【ThreadLocal 局部变量】
1. 某一个线程里面自己的变量set的东西别的线程用不着；get的东西是自己线程的东西不会和其他线程混在一起
2. 在很多的框架中都会用到

集群使用分布式锁（有6、7种实现方法）

数据库的高并发
关系型
建立一个索引/分库/分点/读写分离/主从结构

---------------------------高并发3---------------------------
【并发容器】

【Map/Set】
1. set只包括key，map包括key-value
2. 不加锁：hashMap/TreeMap/LinkedSortedMap/linkedHashMap -- 不需要使用线程的情况系
3. 加锁：hashTable(用的非常少了)；
   不是非常高并发的情况下可以使用：Collections.synchronizedXXX
   输入一个不加锁的容器，通过这个方法对这个容器进行包装，将其中的所有方法都加锁，返回一个加锁的容器
4. 如果需要并发性比较高：concurrentHashMap
   如果需要并发性比较高并且需要排序：concurrentSkipListMap

【Copy On Write】
写时复制 copy on write
多线程环境下 写时效率低 读时效率高
适合写非常少，读特别多的环境
读的时候不需要加锁（因为不会出现脏读的情况）

【Queue】
1. 在不使用线程的情况下：ArrayList/LinkedList
2. 低并发的情况下Collections.synchronizedXXX
【Queue在高并发编程中有两种】
1. ConcurrentLinkedQueue == 内部加锁的队列
2. BlockingQueue == 阻塞式队列
        LinkedBolcking 无界队列
        ArrayBlockingQueue 有界队列
        TransferQueue 直接把生产者的任务交给消费者执行，如果没有消费者执行的恶化他就阻塞（游戏服务器转发消息的时候）
        SynchronousQueue 一种特殊的transferqueue 容量为0
    生产者-消费者，得一直等着
3. DelayQueue 执行定时任务：两个小时之后关机/给出一个警告


并发队列 是加锁不阻塞
阻塞队列是阻塞
注：scala kotlin都是基于jvm的
---------------------------高并发4---------------------------
【线程池框架】

---------------------------高并发5---------------------------
【disruptor】
【netty】